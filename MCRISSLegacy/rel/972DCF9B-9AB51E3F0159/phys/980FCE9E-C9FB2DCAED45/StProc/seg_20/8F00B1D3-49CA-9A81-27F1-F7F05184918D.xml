<?xml version = '1.0' encoding = 'UTF-8'?>
<StoredProcedureSqlServerv2k5 class="oracle.dbtools.crest.model.design.storage.sqlserver.v2k5.StoredProcedureSqlServerv2k5" name="[sp_GetPersonnelSitRepStatsRegion]" directorySegmentName="seg_20" id="8F00B1D3-49CA-9A81-27F1-F7F05184918D">
<sourceDDLFile>Appian.sql</sourceDDLFile>
<createdBy>MichalBonino</createdBy>
<createdTime>2024-04-29 23:57:48 UTC</createdTime>
<ownerDesignName>MCRISSLegacy</ownerDesignName>
<body><![CDATA[@Organiza.onID int, 
 @Month   int, 
 @Year   int 
AS 
 
SET NOCOUNT ON 
 
DECLARE @MonthBeginDate date.me 
SET  @MonthBeginDate = CONVERT(date.me, CONVERT(varchar, @Month) + '/1/' + CONVERT(varchar, @Year)) 
DECLARE @RS_NAME varchar(15) 
 
CREATE TABLE #PROD_STATUS  
 (RS_NAME VARCHAR(45) NULL, RECRUITING_PERSON_ID INT NULL, SHORT_NAME VARCHAR(15) NULL, [NAME] VARCHAR(60) NULL, BILLET VARCHAR(60) NULL, 
 ON_PRODUCTION BIT NULL, NON_PROD_REASON VARCHAR(50) NULL, ORGANIZATION_ID INT NULL) 
 
CREATE TABLE #REG_STAFF (RS_NAME VARCHAR(45) NULL, RECRUITING_PERSON_ID INT NULL, SHORT_NAME VARCHAR(15) NULL, [NAME] VARCHAR(60) NULL, BILLET VARCHAR(60) NULL, 
 ON_PRODUCTION BIT NULL, NON_PROD_REASON VARCHAR(50) NULL, ORGANIZATION_ID INT NULL) 
 
CREATE TABLE #DIST_STAFF (RS_NAME VARCHAR(45) NULL, RECRUITING_PERSON_ID INT NULL, SHORT_NAME VARCHAR(15) NULL, [NAME] VARCHAR(60) NULL, BILLET VARCHAR(60) NULL, 
 ON_PRODUCTION BIT NULL, NON_PROD_REASON VARCHAR(50) NULL, ORGANIZATION_ID INT NULL) 
 
CREATE TABLE #RS_STAFF (RS_NAME VARCHAR(45) NULL, RECRUITING_PERSON_ID INT NULL, SHORT_NAME VARCHAR(15) NULL, [NAME] VARCHAR(60) NULL, BILLET VARCHAR(60) NULL, 
 ON_PRODUCTION BIT NULL, NON_PROD_REASON VARCHAR(50) NULL, ORGANIZATION_ID INT NULL) 
 
CREATE TABLE #ALL_RECRUITERS (RS_NAME VARCHAR(45) NULL, RECRUITING_PERSON_ID INT NULL, SHORT_NAME VARCHAR(15) NULL, [NAME] VARCHAR(60) NULL, BILLET VARCHAR(60) NULL, 
 ON_PRODUCTION BIT NULL, NON_PROD_REASON VARCHAR(50) NULL, ORGANIZATION_ID INT NULL) 
 
--- get the Recruiters, NCOICs etc assigned to the RSSs under the RS's 
INSERT INTO #ALL_RECRUITERS 
SELECT  
 RO2.NAME as RS_NAME, 
 RP.RECRUITING_PERSON_ID, RO.SHORT_NAME, 
 RTRIM(P.LAST_NAME) + SPACE(1) + RTRIM(P.FIRST_NAME) + COALESCE(SPACE(1) + LEFT(P.LEGAL_MIDDLE_NAME, 1), '') AS NAME, 
 BILLET =  CASE  
   --- IF THE BILLET BEGIN DATE IS IN THE MONTH OR PRIOR TO THE MONTH  
   --- SELECT THE RECRUITING ROLE AS THE BILLET 
   WHEN DATEDIFF(MONTH, RP.BILLET_BEGIN_DATE, @MonthBeginDate) >= 0 THEN RR.SHORT_DESCRIPTION  
   ELSE 
    --- OTHERWISE GO TO THE RECRUITER_HISTORY TABLE 
    COALESCE((SELECT TOP 1 RH.BILLET_DESC FROM MCRISS..RECRUITER_HISTORY RH  
      WHERE RH.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID AND  
      DATEDIFF(MONTH, RH.EFFECTIVE_DATE, @MonthBeginDate) = 0 
      ORDER BY RH.BILLET_END_DATE DESC), 
     (SELECT TOP 1 RH.BILLET_DESC FROM MCRISS..RECRUITER_HISTORY RH  
      WHERE RH.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID  
      ORDER BY RH.BILLET_END_DATE DESC), 
     RR.SHORT_DESCRIPTION) 
   END, 
 /* 
 update ON_PRODUCTION and NON_PROD_REASON 
 update ON_PRODUCTION and NON_PROD_REASON logic so that CALENDAR_YEAR <= @Year AND MONTH_CODE <= @Month 
 so that the produc.on status is not changed to "ON" at the beginning of each month 
 the new month value defaults to the old month value 
 */ 
 ON_PRODUCTION = (SELECT TOP 1 PSH.ON_PRODUCTION FROM MCRISS..PRODUCTION_STATUS_HISTORY PSH  
    WHERE PSH.PERSON_ID = RP.RECRUITING_PERSON_ID AND  
    DATEDIFF(MONTH, CONVERT(DATETIME, CONVERT(VARCHAR(2), PSH.MONTH_CODE) + '/1/' +  
     CONVERT(VARCHAR(4), PSH.CALENDAR_YEAR)), @MonthBeginDate) >= 0  
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC),  
 NON_PROD_REASON = (SELECT TOP 1 NPR.SHORT_DESC FROM MCRISS..PRODUCTION_STATUS_HISTORY PSH 
    INNER JOIN MCRISS..NON_PRODUCTION_REASON NPR ON PSH.NON_PROD_REASON_CODE = NPR.REASON_CODE 
    WHERE PSH.PERSON_ID = RP.RECRUITING_PERSON_ID AND 
    DATEDIFF(MONTH, CONVERT(DATETIME, CONVERT(VARCHAR(2), PSH.MONTH_CODE) + '/1/' +  
     CONVERT(VARCHAR(4), PSH.CALENDAR_YEAR)), @MonthBeginDate) >= 0 
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC),  
 RO.ORGANIZATION_ID 
FROM  
 MCRISS..RECRUITING_PERSON RP, MCRISS..RECRUITING_ORGANIZATION RO, 
 MCRISS..PERSON P, MCRISS..RECRUITING_ROLE RR, MCRISS..ORGANIZATION_MAP OM,  
 MCRISS..RECRUITING_ORGANIZATION RO2, MCRISS..ORGANIZATION_MAP OM2,  
 MCRISS..ORGANIZATION_MAP OM3 
WHERE 
 --- get all recruiters where their parent and child orgs are equal to the orgId. 
 --- Filter out the sta. members later. 
 (OM3.PARENT_ORGANIZATION_ID = @Organiza.onID OR OM3.CHILD_ORGANIZATION_ID = @Organiza.onID) AND 
        OM2.PARENT_ORGANIZATION_ID  = OM3.CHILD_ORGANIZATION_ID AND 
        OM.PARENT_ORGANIZATION_ID  = OM2.CHILD_ORGANIZATION_ID AND 
 OM2.CHILD_ORGANIZATION_ID  = RO2.ORGANIZATION_ID AND 
 OM.CHILD_ORGANIZATION_ID  = RO.ORGANIZATION_ID AND 
 OM.CHILD_ORGANIZATION_ID  = RP.ORGANIZATION_ID AND 
 RP.RECRUITING_PERSON_ID  = P.PERSON_ID AND 
 RP.RECRUITING_ROLE_ID   = RR.RECRUITING_ROLE_ID AND 
 --- tour end date is null for all people currently assigned to the unit 
 (RP.TOUR_END_DATE IS NULL OR 
 --- or month is equal to current and prior parameter month  
 (DATEDIFF(MONTH, @MonthBeginDate, RP.TOUR_END_DATE) >= 0))  
 
 
--- get the sta. members assinged to the RS's 
INSERT INTO #RS_STAFF 
SELECT  
 RO.NAME as RS_NAME, 
 RP.RECRUITING_PERSON_ID, 'RS Sta.' AS SHORT_NAME, 
 RTRIM(P.LAST_NAME) + SPACE(1) + RTRIM(P.FIRST_NAME) + COALESCE(SPACE(1) + LEFT(P.LEGAL_MIDDLE_NAME, 1), '') AS NAME, 
 BILLET =  CASE  
   --- IF THE BILLET BEGIN DATE IS IN THE MONTH OR PRIOR TO THE MONTH  
   --- SELECT THE RECRUITING ROLE AS THE BILLET 
   WHEN DATEDIFF(MONTH, RP.BILLET_BEGIN_DATE, @MonthBeginDate) >= 0 THEN RR.SHORT_DESCRIPTION  
   ELSE 
    --- OTHERWISE GO TO THE RECRUITER_HISTORY TABLE 
    COALESCE((SELECT TOP 1 RH.BILLET_DESC FROM MCRISS..RECRUITER_HISTORY RH  
      WHERE RH.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID AND  
      DATEDIFF(MONTH, RH.EFFECTIVE_DATE, @MonthBeginDate) = 0 
      ORDER BY RH.BILLET_END_DATE DESC), 
     (SELECT TOP 1 RH.BILLET_DESC FROM MCRISS..RECRUITER_HISTORY RH  
      WHERE RH.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID  
      ORDER BY RH.BILLET_END_DATE DESC), 
     RR.SHORT_DESCRIPTION) 
   END, 
 /* 
 update ON_PRODUCTION and NON_PROD_REASON 
 update ON_PRODUCTION and NON_PROD_REASON logic so that CALENDAR_YEAR <= @Year AND MONTH_CODE <= @Month 
 so that the produc.on status is not changed to "ON" at the beginning of each month 
 the new month value defaults to the old month value 
 */ 
 ON_PRODUCTION = (SELECT TOP 1 PSH.ON_PRODUCTION FROM MCRISS..PRODUCTION_STATUS_HISTORY PSH  
    WHERE PSH.PERSON_ID = RP.RECRUITING_PERSON_ID AND  
    DATEDIFF(MONTH, CONVERT(DATETIME, CONVERT(VARCHAR(2), PSH.MONTH_CODE) + '/1/' +  
     CONVERT(VARCHAR(4), PSH.CALENDAR_YEAR)), @MonthBeginDate) >= 0  
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC),  
 NON_PROD_REASON = (SELECT TOP 1 NPR.SHORT_DESC FROM MCRISS..PRODUCTION_STATUS_HISTORY PSH 
    INNER JOIN MCRISS..NON_PRODUCTION_REASON NPR ON PSH.NON_PROD_REASON_CODE = NPR.REASON_CODE 
    WHERE PSH.PERSON_ID = RP.RECRUITING_PERSON_ID AND 
    DATEDIFF(MONTH, CONVERT(DATETIME, CONVERT(VARCHAR(2), PSH.MONTH_CODE) + '/1/' +  
     CONVERT(VARCHAR(4), PSH.CALENDAR_YEAR)), @MonthBeginDate) >= 0 
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC),  
 RO.ORGANIZATION_ID 
FROM  
 MCRISS..RECRUITING_PERSON RP, MCRISS..RECRUITING_ORGANIZATION RO, 
 MCRISS..PERSON P, MCRISS..RECRUITING_ROLE RR, MCRISS..ORGANIZATION_MAP OM,  
 MCRISS..RECRUITING_ORGANIZATION RO2, MCRISS..ORGANIZATION_MAP OM2 
WHERE 
 OM2.PARENT_ORGANIZATION_ID = @Organiza.onID AND 
        OM.PARENT_ORGANIZATION_ID  = OM2.CHILD_ORGANIZATION_ID AND 
 OM2.CHILD_ORGANIZATION_ID  = RO2.ORGANIZATION_ID AND 
 OM.CHILD_ORGANIZATION_ID  = RO.ORGANIZATION_ID AND 
 OM.CHILD_ORGANIZATION_ID  = RP.ORGANIZATION_ID AND 
 RP.RECRUITING_PERSON_ID  = P.PERSON_ID AND 
 RP.RECRUITING_ROLE_ID   = RR.RECRUITING_ROLE_ID AND 
 --- tour end date is null for all people currently assigned to the unit 
 (RP.TOUR_END_DATE IS NULL OR 
 --- or month is equal to current and prior parameter month  
 (DATEDIFF(MONTH, @MonthBeginDate, RP.TOUR_END_DATE) >= 0)) /*and 
 --- sta. member orgId's will only equal the parent orgid, exclude others 
 rp.organiza.on_id <> (select top 1 psh.organiza.on_id from produc.on_status_history psh 
    where psh.person_id = rp.recrui.ng_person_id and 
    ((psh.calendar_year = @Year and psh.month_code <= @Month) OR (PSH.CALENDAR_YEAR <= @Year))  
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC) and 
 --- check that sta. member is o. produc.on for that month/year 
 0 = (select top 1 psh.on_produc.on from produc.on_status_history psh 
    where psh.person_id = rp.recrui.ng_person_id and 
    ((psh.calendar_year = @Year and psh.month_code <= @Month)) ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC)  
 */ 
 
--- get the sta. members assinged to the Dist's 
INSERT INTO #DIST_STAFF 
SELECT  
 RO.NAME as RS_NAME, 
 RP.RECRUITING_PERSON_ID, 'Dist Sta.' AS SHORT_NAME, 
 RTRIM(P.LAST_NAME) + SPACE(1) + RTRIM(P.FIRST_NAME) + COALESCE(SPACE(1) + LEFT(P.LEGAL_MIDDLE_NAME, 1), '') AS NAME, 
 BILLET =  CASE  
   --- IF THE BILLET BEGIN DATE IS IN THE MONTH OR PRIOR TO THE MONTH  
   --- SELECT THE RECRUITING ROLE AS THE BILLET 
   WHEN DATEDIFF(MONTH, RP.BILLET_BEGIN_DATE, @MonthBeginDate) >= 0 THEN RR.SHORT_DESCRIPTION  
   ELSE 
    --- OTHERWISE GO TO THE RECRUITER_HISTORY TABLE 
    COALESCE((SELECT TOP 1 RH.BILLET_DESC FROM MCRISS..RECRUITER_HISTORY RH  
      WHERE RH.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID AND  
      DATEDIFF(MONTH, RH.EFFECTIVE_DATE, @MonthBeginDate) = 0 
      ORDER BY RH.BILLET_END_DATE DESC), 
     (SELECT TOP 1 RH.BILLET_DESC FROM MCRISS..RECRUITER_HISTORY RH  
      WHERE RH.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID  
      ORDER BY RH.BILLET_END_DATE DESC), 
     RR.SHORT_DESCRIPTION) 
   END, 
 /* 
 update ON_PRODUCTION and NON_PROD_REASON 
 update ON_PRODUCTION and NON_PROD_REASON logic so that CALENDAR_YEAR <= @Year AND MONTH_CODE <= @Month 
 so that the produc.on status is not changed to "ON" at the beginning of each month 
 the new month value defaults to the old month value 
 */ 
 ON_PRODUCTION = (SELECT TOP 1 PSH.ON_PRODUCTION FROM MCRISS..PRODUCTION_STATUS_HISTORY PSH  
    WHERE PSH.PERSON_ID = RP.RECRUITING_PERSON_ID AND  
    DATEDIFF(MONTH, CONVERT(DATETIME, CONVERT(VARCHAR(2), PSH.MONTH_CODE) + '/1/' +  
     CONVERT(VARCHAR(4), PSH.CALENDAR_YEAR)), @MonthBeginDate) >= 0  
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC),  
 NON_PROD_REASON = (SELECT TOP 1 NPR.SHORT_DESC FROM MCRISS..PRODUCTION_STATUS_HISTORY PSH 
    INNER JOIN MCRISS..NON_PRODUCTION_REASON NPR ON PSH.NON_PROD_REASON_CODE = NPR.REASON_CODE 
    WHERE PSH.PERSON_ID = RP.RECRUITING_PERSON_ID AND 
    DATEDIFF(MONTH, CONVERT(DATETIME, CONVERT(VARCHAR(2), PSH.MONTH_CODE) + '/1/' +  
     CONVERT(VARCHAR(4), PSH.CALENDAR_YEAR)), @MonthBeginDate) >= 0 
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC),  
 RO.ORGANIZATION_ID  
FROM  
 MCRISS..RECRUITING_PERSON RP, MCRISS..RECRUITING_ORGANIZATION RO, 
 MCRISS..PERSON P, MCRISS..RECRUITING_ROLE RR, MCRISS..ORGANIZATION_MAP OM 
WHERE 
 OM.PARENT_ORGANIZATION_ID = @Organiza.onID AND 
 OM.CHILD_ORGANIZATION_ID  = RO.ORGANIZATION_ID AND 
 OM.CHILD_ORGANIZATION_ID  = RP.ORGANIZATION_ID AND 
 RP.RECRUITING_PERSON_ID  = P.PERSON_ID AND 
 RP.RECRUITING_ROLE_ID   = RR.RECRUITING_ROLE_ID AND 
 --- tour end date is null for all people currently assigned to the unit 
 (RP.TOUR_END_DATE IS NULL OR 
 --- or month is equal to current and prior parameter month  
 (DATEDIFF(MONTH, @MonthBeginDate, RP.TOUR_END_DATE) >= 0)) /*and 
 --- sta. member orgId's will only equal the parent orgid, exclude others 
 rp.organiza.on_id <> (select top 1 psh.organiza.on_id from produc.on_status_history psh 
    where psh.person_id = rp.recrui.ng_person_id and 
    ((psh.calendar_year = @Year and psh.month_code <= @Month) OR (PSH.CALENDAR_YEAR <= @Year))  
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC) and 
 --- check that sta. member is o. produc.on for that month/year 
 0 = (select top 1 psh.on_produc.on from produc.on_status_history psh 
    where psh.person_id = rp.recrui.ng_person_id and 
    ((psh.calendar_year = @Year and psh.month_code <= @Month)) ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC)   
 */ 
 
--- get the sta. members assinged to the Region 
INSERT INTO #REG_STAFF 
SELECT  
 RO.NAME as RS_NAME, 
 RP.RECRUITING_PERSON_ID, 'Reg Sta.' AS SHORT_NAME, 
 RTRIM(P.LAST_NAME) + SPACE(1) + RTRIM(P.FIRST_NAME) + COALESCE(SPACE(1) + LEFT(P.LEGAL_MIDDLE_NAME, 1), '') AS NAME, 
 BILLET =  CASE  
    --- IF THE BILLET BEGIN DATE IS IN THE MONTH OR PRIOR TO THE MONTH  
    --- SELECT THE RECRUITING ROLE AS THE BILLET 
    WHEN DATEDIFF(MONTH, RP.BILLET_BEGIN_DATE, @MonthBeginDate) >= 0 THEN RR.SHORT_DESCRIPTION  
    ELSE 
     --- OTHERWISE GO TO THE RECRUITER_HISTORY TABLE 
     COALESCE((SELECT TOP 1 RH.BILLET_DESC FROM MCRISS..RECRUITER_HISTORY RH  
       WHERE RH.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID AND  
       DATEDIFF(MONTH, RH.EFFECTIVE_DATE, @MonthBeginDate) = 0 
       ORDER BY RH.BILLET_END_DATE DESC), 
      (SELECT TOP 1 RH.BILLET_DESC FROM MCRISS..RECRUITER_HISTORY RH  
       WHERE RH.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID  
       ORDER BY RH.BILLET_END_DATE DESC), 
      RR.SHORT_DESCRIPTION) 
     END, 
 /* 
 update ON_PRODUCTION and NON_PROD_REASON 
 update ON_PRODUCTION and NON_PROD_REASON logic so that CALENDAR_YEAR <= @Year AND MONTH_CODE <= @Month 
 so that the produc.on status is not changed to "ON" at the beginning of each month 
 the new month value defaults to the old month value 
 */ 
 ON_PRODUCTION = (SELECT TOP 1 PSH.ON_PRODUCTION FROM MCRISS..PRODUCTION_STATUS_HISTORY PSH  
    WHERE PSH.PERSON_ID = RP.RECRUITING_PERSON_ID AND  
    ((PSH.CALENDAR_YEAR = @Year AND PSH.MONTH_CODE <= @Month) OR (PSH.CALENDAR_YEAR <= @Year)) ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC), 
 NON_PROD_REASON = (SELECT TOP 1 NPR.SHORT_DESC FROM MCRISS..PRODUCTION_STATUS_HISTORY PSH, MCRISS..NON_PRODUCTION_REASON NPR WHERE PSH.PERSON_ID = RP.RECRUITING_PERSON_ID AND PSH.NON_PROD_REASON_CODE *= NPR.REASON_CODE AND (( 
    PSH.CALENDAR_YEAR = @Year AND PSH.MONTH_CODE <= @Month) OR (PSH.CALENDAR_YEAR <= @Year)) ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC),   
 RO.ORGANIZATION_ID  
FROM  
 MCRISS..RECRUITING_PERSON RP, MCRISS..RECRUITING_ORGANIZATION RO, 
 MCRISS..PERSON P, MCRISS..RECRUITING_ROLE RR  
WHERE 
 RO.ORGANIZATION_ID = @Organiza.onID AND 
 RO.ORGANIZATION_ID  = RP.ORGANIZATION_ID AND 
 RP.RECRUITING_PERSON_ID = P.PERSON_ID AND 
 
 RP.RECRUITING_ROLE_ID  = RR.RECRUITING_ROLE_ID AND 
 --- tour end date is null for all people currently assigned to the unit 
 (RP.TOUR_END_DATE IS NULL OR 
 --- or month is equal to current and prior parameter month  
 (DATEDIFF(MONTH, @MonthBeginDate, RP.TOUR_END_DATE) >= 0))  
 
 /* 
 RECRUITING_PERSON RP INNER JOIN RECRUITING_ORGANIZATION RO ON 
  (RP.ORGANIZATION_ID = @Organiza.onID AND 
  RP.ORGANIZATION_ID = RO.ORGANIZATION_ID AND 
  --- TOUR END DATE IS NULL FOR ALL PEOPLE CURRENTLY ASSIGNED TO THE UNIT 
  RP.TOUR_END_DATE IS NULL) 
 INNER JOIN PERSON P ON RP.RECRUITING_PERSON_ID = P.PERSON_ID 
 INNER JOIN RECRUITING_ROLE RR ON RP.RECRUITING_ROLE_ID = RR.RECRUITING_ROLE_ID 
 */ 
 
/* 
FROM  
 MCRISS..RECRUITING_PERSON RP, MCRISS..RECRUITING_ORGANIZATION RO, 
 MCRISS..PERSON P, MCRISS..RECRUITING_ROLE RR  
WHERE 
 RO.ORGANIZATION_ID = @Organiza.onID AND 
 RO.ORGANIZATION_ID  = RP.ORGANIZATION_ID AND 
 RP.RECRUITING_PERSON_ID = P.PERSON_ID AND 
 RP.RECRUITING_ROLE_ID  = RR.RECRUITING_ROLE_ID AND 
 --- tour end date is null for all people currently assigned to the unit 
 (RP.TOUR_END_DATE IS NULL OR 
 --- or month is equal to current and prior parameter month  
 (DATEDIFF(MONTH, @MonthBeginDate, RP.TOUR_END_DATE) >= 0))  
 and 
 --- sta. member orgId's will only equal the parent orgid, exclude others 
 rp.organiza.on_id <> (select top 1 psh.organiza.on_id from produc.on_status_history psh 
    where psh.person_id = rp.recrui.ng_person_id and 
    ((psh.calendar_year = @Year and psh.month_code <= @Month) OR (PSH.CALENDAR_YEAR <= @Year))  
    ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC) and 
 --- check that sta. member is o. produc.on for that month/year 
 0 = (select top 1 psh.on_produc.on from produc.on_status_history psh 
    where psh.person_id = rp.recrui.ng_person_id and 
    ((psh.calendar_year = @Year and psh.month_code <= @Month)) ORDER BY PSH.CALENDAR_YEAR DESC, PSH.MONTH_CODE DESC)   
 */ 
 
 
/* 
SELECT 
 RP.RECRUITING_PERSON_ID, 
 RP.ORGANIZATION_ID, 
 RR.RECRUITING_ROLE_ID, 
 RR.SHORT_DESCRIPTION, 
 RO.SHORT_NAME, 
 P.LAST_NAME + ', ' + P.FIRST_NAME + COALESCE(SPACE(1) + P.LEGAL_MIDDLE_NAME, SPACE(0)) AS [NAME], 
 COALESCE(RP.RANK_CODE, SPACE(0)) AS RANK, 
 RO.ORGANIZATION_TYPE 
FROM  
 
 RECRUITING_PERSON RP INNER JOIN RECRUITING_ORGANIZATION RO ON 
  (RP.ORGANIZATION_ID = @Organiza.onID AND 
  RP.ORGANIZATION_ID = RO.ORGANIZATION_ID AND 
  --- TOUR END DATE IS NULL FOR ALL PEOPLE CURRENTLY ASSIGNED TO THE UNIT 
  RP.TOUR_END_DATE IS NULL) 
 INNER JOIN PERSON P ON RP.RECRUITING_PERSON_ID = P.PERSON_ID 
 INNER JOIN RECRUITING_ROLE RR ON RP.RECRUITING_ROLE_ID = RR.RECRUITING_ROLE_ID 
ORDER BY  
 [NAME] 
*/ 
 
--- Populate prod_status with all recruiters who are not sta. members 
INSERT INTO #PROD_STATUS 
SELECT  
 RS_NAME, 
 RECRUITING_PERSON_ID, 
 SHORT_NAME, 
 [NAME], 
 BILLET, 
 ON_PRODUCTION, 
 NON_PROD_REASON, 
 ORGANIZATION_ID 
FROM  
 #ALL_RECRUITERS R 
WHERE NOT EXISTS (SELECT 1 FROM #RS_STAFF S WHERE S.RECRUITING_PERSON_ID = R.RECRUITING_PERSON_ID) 
AND NOT EXISTS (SELECT 1 FROM #DIST_STAFF D WHERE D.RECRUITING_PERSON_ID = R.RECRUITING_PERSON_ID) 
AND NOT EXISTS (SELECT 1 FROM #REG_STAFF G WHERE G.RECRUITING_PERSON_ID = R.RECRUITING_PERSON_ID) 
 
 
--- Populate prod_status with RS sta. members 
INSERT INTO #PROD_STATUS 
SELECT * FROM #RS_STAFF 
 
--- Populate prod_status with District sta. members 
INSERT INTO #PROD_STATUS 
SELECT * FROM #DIST_STAFF 
 
--- Populate prod_status with Regional sta. members 
INSERT INTO #PROD_STATUS 
SELECT * FROM #REG_STAFF 
 
 
--- UPDATE THE TEMP TABLE AND SET ANY NULL VALUES FOR ON_PRODUCTION TO 0 FOR OFF PRODUCTION 
UPDATE #PROD_STATUS SET ON_PRODUCTION = 0 WHERE ON_PRODUCTION IS NULL 
 
 
/* 
*/ 
--- RETURN THE RESULT SET 
SELECT   
 COALESCE(RS_NAME, SPACE(0)) AS RS_NAME,  
 COALESCE(M.PRIMARY_MOS, SPACE(0)) AS PRIMARY_MOS,   
 COALESCE(M.BILLET_MOS, SPACE(0)) AS BILLET_MOS, 
 M.EXPIRATION_OF_ACTIVE_SERVICE EAS, 
 RP.RECRUITING_PERSON_ID,  
 COALESCE(SHORT_NAME, SPACE(0)) AS SHORT_NAME,  
 COALESCE([NAME], SPACE(0)) AS [NAME],  
 COALESCE(BILLET, SPACE(0)) AS BILLET,  
 PS.ON_PRODUCTION,  
 COALESCE(NON_PROD_REASON, SPACE(0)) AS NON_PROD_REASON,  
 PS.ORGANIZATION_ID,  
 COALESCE(RR.PRODUCTION_BILLET, 'N') AS PRODUCTION_BILLET, 
 CASE  
  WHEN EXISTS (SELECT MARINE_ID FROM INTENDED_MOS IM WHERE IM.MARINE_ID = PS.RECRUITING_PERSON_ID) THEN 'Y' 
  ELSE 'N' 
 END AS IMOS,  
 COALESCE(M.COMPONENT_CODE, SPACE(0)) AS COMPONENT_CODE 
FROM  
 #PROD_STATUS PS LEFT OUTER JOIN MCRISS..MARINE M ON PS.RECRUITING_PERSON_ID = M.MARINE_ID 
 INNER JOIN RECRUITING_PERSON RP ON 
 PS.RECRUITING_PERSON_ID = RP.RECRUITING_PERSON_ID 
 LEFT OUTER JOIN MCRISS..RECRUITING_ROLE RR ON RP.RECRUITING_ROLE_ID = RR.RECRUITING_ROLE_ID 
WHERE  
 PRESENT_GRADE_CODE LIKE 'E%'  
 --- AND M.BILLET_MOS IN ('8411', '8412') 
ORDER BY  
 RS_NAME, SHORT_NAME, [NAME] 
 
--- CLEAN UP 
SET NOCOUNT OFF 
 
DROP TABLE #PROD_STATUS 
DROP TABLE #RS_STAFF 
DROP TABLE #DIST_STAFF 
DROP TABLE #REG_STAFF 
DROP TABLE #ALL_RECRUITERS]]></body>
<schema>DD6CF638-A2EB-2E1B-FF13-422CA718DE2D</schema>
<database>EA42DEDC-DFC5-B775-3079-AD0E133F5E1D</database>
</StoredProcedureSqlServerv2k5>